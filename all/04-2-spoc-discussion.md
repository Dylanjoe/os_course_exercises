#lec9: 虚存置换算法spoc练习

## 视频相关思考题

### 9.1 页面置换算法的概念

1. 设计置换算法时需要考虑哪些影响因素？如何评判的好坏？

2. 全局和局部置换算法的不同？

### 9.2 最优算法、先进先出算法和最近最久未使用算法

1. 最优算法、先进先出算法和LRU算法的思路？

### 9.3 时钟置换算法和最不常用算法

1. 时钟置换算法的思路？

2. 改进的时钟置换算法与时钟置换算法有什么不同？

3. LFU算法的思路？


### 9.4 Belady现象和局部置换算法比较

1. 什么是Belady现象？如何判断一种置换算法是否存在Belady现象？

2. 请证明LRU算法不存在Belady现象。

### 9.5 工作集置换算法

1. CPU利用率与并发进程数的关系是什么？

2. 什么是工作集？

3. 什么是常驻集？

4. 工作集算法的思路？

### 9.6 缺页率置换算法

1. 缺页率算法的思路？

### 9.7 抖动和负载控制

1. 什么是虚拟内存管理的抖动现象？

2. 操作系统负载控制的最佳状态是什么状态？

3. 局部置换算法（如FIFO, LRU等）是否能作为全局置换算法来使用？为什么？

----

## 扩展思考题

1.  改进时钟置换算法的极端情况: 如果所有的页面都被修改过了，这时需要分配新的页面时，算法的performance会如何？能否改进在保证正确的前提下提高缺页中断的处理时间？

2.  如何设计改进时钟算法的写回策略?

3. （spoc）根据你的`学号 mod 4`的结果值，确定选择四种页面置换算法（0：LRU置换算法，1:改进的clock 页置换算法，2：工作集页置换算法，3：缺页率置换算法）中的一种来设计一个应用程序（可基于python, ruby, C, C++，LISP等）模拟实现，并给出测试用例和测试结果。请参考如python代码或独自实现。
 - [页置换算法实现的参考实例](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab3/page-replacement-policy.py)     

4. 请判断OPT、LRU、FIFO、Clock和LFU等各页面置换算法是否存在Belady现象？如果存在，给出实例；如果不存在，给出证明。

5. 了解LIRS页置换算法的设计思路，尝试用高级语言实现其基本思路。此算法是江松博士（导师：张晓东博士）设计完成的，非常不错！
	- 参考信息：
 	- [LIRS conf paper](http://www.ece.eng.wayne.edu/~sjiang/pubs/papers/jiang02_LIRS.pdf)
	 - [LIRS journal paper](http://www.ece.eng.wayne.edu/~sjiang/pubs/papers/jiang05_LIRS.pdf)
	 - [LIRS-replacement ppt1](http://dragonstar.ict.ac.cn/course_09/XD_Zhang/(6)-LIRS-replacement.pdf)
	 - [LIRS-replacement ppt2](http://www.ece.eng.wayne.edu/~sjiang/Projects/LIRS/sig02.ppt)



## 问答题

#### Q1：[基础] 全局和局部置换算法有何不同？分别有哪些算法？

A:

* 局部：置换范围仅限当前进程页面，某个进程页面数量固定；OPT、FIFO、LRU、Clock、LFU
* 全局：置换范围为所有允许置换的物理页面；工作集算法、缺页率算法

#### Q2：[基础] 简单描述OPT、FIFO、LRU、Clock、LFU的工作过程和特点

A:

* OPT：换出未来最晚使用的页面；不可能实现，作为benchmark
* FIFO：换出最早进入内存的页面；开销小、实现简单（更新很少，仅在换入换出时更新），效率较低
* LRU：换出最久未使用的页面；开销大、实现比较困难，较精确，实际使用仍然比较少
* Clock：设置访问位，访问时置1，缺页时循环遍历页面，访问位为1者置0，访问下一个页面，为0者换出，结束（注意换出后，指针指向下一个页面）；为FIFO、LRU折中，开销和效果适中
* LFU：记录每个页面的访问次数，缺页时换出访问次数最少的；开销较大，硬件实现困难，多用于磁盘访问的情景

#### Q3：[进阶，开放，推荐]考虑置换算法的收益和开销，综合评判在何种情境下使用何种算法比较合适呢？

*提示：不仅限于内存和磁盘之间的置换，考虑层次存储中各个层次之间的置换。综合考虑每次访问和缺失时的开销。*

*参考引导问题：为何LRU可以实现且效果好但不大范围使用？为何在TLB中经常使用random替换算法？*

A:访问开销 = hit开销 + miss率 X miss开销，要综合考虑命中和不命中开销。在不同的存储层次，命中开销的基础值相差很大，在TLB层级，基础开销相当小，这时如果算法附带的命中开销稍大，那么即便缺失率很小也得不偿失，所以经常使用随机算法，另外这个层次的算法必须有硬件高效实现，这也限制了算法的选取。而访问磁盘的情境下，每次读取量大、时间长，基础开销很大，这个时候就可以选取一些基础开销稍大的算法来减少miss开销，可以使用软件算法。

#### Q4：[基础] Clock和LFU算法存在那些问题，如何改进？

A:

* Clock
  * 问题：如果换出的是已经修改的页面，本次开销比较大（事实上这个问题所有算法都有这个问题，可能是clock可以比较方便的进行针对性优化，因为用到了页表项·）
  * 改进：增加一个修改位，对于已经修改的页面先跳过不换出，等待其余机制（开销小）写出后再考虑换出。
* LFU
  * 某些页面如果累计次数很高，即便长时间不访问也不会被换出
  * 定期对访问次数进行右移

#### Q5：[进阶-，开放] Clock算法仅仅能够记录近期是否访问过这一信息，对于访问的频度几乎没有记录，如何改进这一点？（这里针对恢复计数的LFU算法也可以提出类似问题.）

A:将访问位拓宽，访问时+1，封顶不加，缺页循环时-1，到0不减，这样可以一定程度上记录已经访问过的页的访问频度。

#### Q6：[基础] LRU算法的缺页率是否总是优于FIFO算法呢？为何？

A:不是，有时候退化，甚至可能更差。这些算法都是基于局部性原理的，有些时刻可能失效。

#### Q7：[基础] 描述belady现象。[进阶] 哪些算法有belady现象？[困难]思考belady现象的成因，尝试给出说明OPT和LRU等没有belady现象的思路（仅仅是思路，大体有一个方向即可）。

A:参考思路：如果能够使得页面增多时驻留内存的页面总是内存不变时的超集就可以整明没有belady，也就是说要维护所有页面的一个全序关系。考虑内存页面无限多的情况，LRU和OPT有这样一个全序关系，恢复计数的LFU也有这样的关系。但是不恢复计数的LFU页面一旦被换出，这个关系就崩了，所以它存在belady。

附录：[LRU参考证明](https://piazza.com/class/i5j09fnsl7k5x0?cid=205)，[OPT参考证明](https://piazza.com/class/i5j09fnsl7k5x0?cid=1296)

#### Q8：[进阶] 使用自映射有何优势？有何代价？

A:

优势：省一个页面的内存(这不关键)。可以通过十分简单的运算，由虚拟地址直接得到所需的二级页表项的物理地址。方便编辑页表自身；

代价：会占用一大片虚拟地址空间。

#### Q9：[基础] 为何要使用自映射？除了自映射还可以使用什么方法？

A:为了方便地访问页表，因为我们需要一种机制把页表页目录的物理地址转换成虚拟地址。偏移映射等……

#### Q10：[进阶] 考虑在 32 位 x86 下使用页表自映射。为了方便用三元组 (a, b, c) 表示虚拟/物理地址 ((a<<22)  +(b<<12) + c)，其中 0<=a,b<1024，0<=c<4096。假设页目录的物理地址是 (A, B, 0)，并且页目录的第 e 项  (0<=e<1024) 是自映射项，就是说在 (A, B, 4*e) 页目录项指向页目录自己的物理地址 (A, B, 0).

**Question1：页目录的第 i 项的物理地址是多少？通过自映射访问的虚拟地址是多少？**

A: (A, B, 4\*i) ; (e, e, 4\*i)

**Question2：用一句赋值语句，取消虚拟地址 (x,y,0) 所在页的地址映射。那重新映射到物理地址 (C,D,0)呢（用 flags 表示页表项的诸标志位）？**

A:

\*(pte\*) (e, x, 4\*y) = 0

\*(pte\*) (e, x, 4\*y) = (C,D,0) | flags.

**Question3：页表项指向的页的物理地址可以直接从页表项的内容读出。但采用自映射后，为什么把页表项的地址（最后两位清零）左移10位，就得到了页表项指向的页的虚拟地址了？**

A:采用自映射以后，页表/页目录均在地址 (e, 0, 0) 到 (e, 1023, 0) 内存区域内。虚拟地址 (u, v, w) 对应的页表项在 (e, u, 4\*v)，画图即可。